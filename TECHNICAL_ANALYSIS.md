# Технический анализ: Vibe README Maven Plugin

## Обзор проекта

**Vibe README Maven Plugin** - это специализированный Maven-плагин для автоматической генерации документации конфигурационных параметров Spring Boot приложений. Плагин анализирует классы с аннотацией `@ConfigurationProperties` и поля с `@Value`, создавая структурированные Markdown-таблицы для README.md файлов.

## Архитектурные особенности

### Двухфазная архитектура

Плагин реализует **двухфазную архитектуру** с двумя независимыми Maven goals:

#### 1. `generate-metadata` (Фаза: `process-classes`)
- **Цель**: создание метаданных для библиотек
- **Фаза**: `process-classes` (после компиляции классов)
- **Выход**: `target/classes/META-INF/readme-annotations.json`
- **Назначение**: подготовка метаданных для повторного использования в зависимых проектах

#### 2. `generate-readme` (Фаза: `verify`)
- **Цель**: генерация полной документации
- **Фаза**: `verify` (финальная валидация перед установкой)
- **Выход**: `README.md` (в корне проекта)
- **Назначение**: сбор и объединение всех конфигурационных параметров

### Почему именно эти фазы?

**`process-classes`** для `generate-metadata`:
- Выполняется после компиляции, когда `.class` файлы доступны для анализа
- Позволяет включать метаданные в JAR-файлы библиотек
- Гарантирует, что все классы скомпилированы перед анализом

**`verify`** для `generate-readme`:
- Финальная фаза жизненного цикла Maven
- Выполняется после всех тестов и сборок
- Позволяет собрать метаданные из всех зависимостей
- Гарантирует, что документация генерируется только при успешной сборке

## Технические особенности

### 1. Анализ байткода с использованием ASM

#### Что такое ASM?
**ASM** - это легковесная Java библиотека для манипуляции байткодом Java. В отличие от рефлексии, ASM работает напрямую с скомпилированными `.class` файлами, обеспечивая:

- **Высокую производительность** - анализ без загрузки классов в JVM
- **Доступ к метаданным** - чтение аннотаций, сигнатур типов, констант
- **Низкие накладные расходы** - минимальное потребление памяти

#### ASM-компоненты в проекте

**`AsmInstanceFieldDetector`**:
```java
public static boolean hasInstanceFields(String internalName, Map<String, Path> classIndexByInternalName, Log log)
```
- Определяет, содержит ли класс поля экземпляра (не статические, не финальные)
- Используется для различения "контейнерных" объектов от скалярных свойств
- Применяет оптимизацию: сначала ищет в локальном индексе, затем в classpath

**`AsmReadmeFieldSupport`**:
- **Форматирование обобщенных типов**: извлечение типов из сигнатур полей (`List<String>`, `Map<K,V>`)
- **Извлечение значений по умолчанию**: анализ конструкторов для константных инициализаций
- **Поддержка коллекций**: преобразование `List.of()`, `Map.of()` в JSON-представление

### 2. Продвинутый анализ типов

#### `EnglishHumanReadableTypeResolver`
Преобразует Java-типы в человекочитаемые названия:

```java
public static String toHumanReadableType(String javaType)
```

**Правила трансформации**:
- `String` → `string`
- `Integer`, `Long`, `Short` → `integer`
- `Double`, `Float` → `number`
- `Boolean` → `boolean`
- `List<T>` → `list(T)`
- `Map<K,V>` → `map(string,V)`
- Массивы → `list(component-type)`

#### Контекстно-зависимое разрешение
```java
private enum Context {
    TOP_LEVEL_SCALAR,  // для скалярных свойств
    NESTED             // для вложенных элементов коллекций
}
```

### 3. Обработка аннотаций

#### Поддерживаемые аннотации

**`@ConfigurationProperties`**:
- Извлекает `prefix` для формирования имен свойств
- Группирует связанные свойства

**`@Readme`** (кастомная аннотация):
- Предоставляет описания для свойств и групп
- Опциональная для полей (можно включить недокументированные)

**`@Value`**:
- Поддержка выражений типа `${property.name:default}`
- Извлечение имени свойства и значения по умолчанию

**`@JsonProperty`**:
- Альтернативное именование полей для Jackson

### 4. Анализ конфигурационных файлов

#### Поддержка форматов
- `application.yml` (YAML)
- `application.yaml`
- `application.properties`

#### Приоритеты поиска
1. Путь из параметра `defaultConfigFile`
2. `src/main/resources/application.yml`
3. `src/main/resources/application.yaml`
4. `src/main/resources/application.properties`

#### Функциональность
- Перезапись значений по умолчанию из кода
- Извлечение значений для прямых полей `@ConfigurationProperties`
- Значения из файлов имеют приоритет над кодом

### 5. Рекурсивная обработка вложенных объектов

Плагин автоматически обрабатывает вложенные конфигурационные классы:

```java
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    @Readme("Настройки базы данных")
    private DatabaseConfig database;  // генерирует: app.database.*
}
```

### 6. Обогащение описаний для java.time

#### Автоматические подсказки формата
- `Duration` → добавляется *(формат: ISO-8601, например: PT10M, PT2H30M)*
- `LocalDateTime` → *(формат: ISO-8601, например: 2023-12-31T23:59:59)*
- `LocalDate`, `LocalTime`, `Instant`, `ZonedDateTime` → аналогично

### 7. Инкрементальное обновление README

#### Маркеры для обновления
```markdown
<!-- README-PARAMS-BEGIN -->
[сгенерированное содержимое]
<!-- README-PARAMS-END -->
```

- Сохраняет существующее содержимое README
- Заменяет только секцию между маркерами
- Безопасное обновление без потери ручного контента

### 8. Многоязычная поддержка

#### `LocalizationProvider`
- **Русский** (`ru`): "Имя настройки", "Обяз.", "Тип", "По умолчанию", "Описание"
- **Английский** (`en`): "Property Name", "Req.", "Type", "Default", "Description"
- Расширяемая архитектура для добавления языков

### 9. Цветная подсветка

#### HTML-спаны для GitHub
```html
<span style="color:red">Да</span>    <!-- обязательные -->
<span style="color:green">Нет</span> <!-- необязательные -->
```

## Технические решения

### 1. Производительность и оптимизации

#### Локальный индекс классов
```java
Map<String, Path> classIndexByInternalName
```
- Предварительное сканирование всех `.class` файлов
- Быстрый доступ к файлам без поиска в classpath
- Кэширование для повторных обращений

#### ASM оптимизации
- `ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES`
- Чтение только метаданных, без тела методов
- Минимальный парсинг для требуемой информации

### 2. Обработка исключений

#### Graceful degradation
- Ошибки анализа отдельных классов не останавливают весь процесс
- Подробное логирование с уровнями `info`, `debug`, `warn`
- Продолжение работы при частичных неудачах

### 3. Расширяемость

#### Модульная архитектура
- Отдельные сервисы для разных аспектов анализа
- Интерфейсы для добавления новых типов аннотаций
- Параметризованная конфигурация поведения

### 4. Потокобезопасность

#### Stateless дизайн
- Все компоненты не имеют состояния
- Безопасное использование в многопоточной среде Maven
- Логирование через переданный `Log` интерфейс

## Интеграция с Maven

### Параметры конфигурации

| Параметр | Тип | По умолчанию | Описание |
|----------|-----|--------------|----------|
| `skip` | boolean | false | Пропустить выполнение плагина |
| `locale` | String | ru | Локаль для заголовков (ru/en) |
| `coloredOutput` | boolean | false | Цветная подсветка обязательных полей |
| `sortByRequired` | boolean | false | Сортировка по обязательности |
| `analyzeConfigFiles` | boolean | false | Анализ конфигурационных файлов |
| `includeUndocumentedProperties` | boolean | false | Включать недокументированные свойства |
| `includeValueAnnotations` | boolean | false | Сканировать поля с @Value |

### Свойства Maven
```bash
mvn verify -Dvibe-readme.locale=en
mvn verify -Dvibe-readme.sortByRequired=true
mvn verify -Dvibe-readme.analyzeConfigFiles=true
```

## Заключение

Vibe README Maven Plugin представляет собой комплексное решение для автоматической генерации документации Spring Boot приложений. Использование ASM для анализа байткода обеспечивает высокую производительность и точность извлечения метаданных. Двухфазная архитектура позволяет эффективно работать как с библиотеками, так и с конечными приложениями.

Ключевые инновации:
- **ASM-интеграция** для глубокого анализа скомпилированного кода
- **Рекурсивная обработка** вложенных конфигураций
- **Инкрементальное обновление** README без потери контента
- **Многоуровневая поддержка типов** включая java.time и коллекции
- **Расширяемая локализация** и конфигурация

Проект демонстрирует современные подходы к метапрограммированию в Java экосистеме.
